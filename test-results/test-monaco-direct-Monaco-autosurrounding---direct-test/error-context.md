# Page snapshot

```yaml
- generic [active] [ref=e1]:
  - heading "Cleansheet Career Canvas - Interactive Career Management Platform" [level=1] [ref=e2]
  - text:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
  - generic [ref=e3]:
    - generic [ref=e4]:
      - heading "Interview Preparation" [level=2] [ref=e5]
      - button "×" [ref=e6] [cursor=pointer]
    - text:                                                                                                
  - text: "                                                         `); printWindow.document.close(); document.getElementById('markdownDownloadMenu').style.display = 'none'; console.log('[Markdown Download] Opening print dialog for PDF'); if (typeof showToast === 'function') { showToast('Opening print dialog - Save as PDF', 'info'); } } // Download as DOCX (using docx.js - requires library) function downloadMarkdownAsDocx() { const asset = getCurrentMarkdownAsset(); if (!asset) return; // For now, show a message that DOCX export requires additional setup // In a full implementation, you would use a library like docx.js or html-docx-js console.warn('[Markdown Download] DOCX export requires docx.js library'); if (typeof showToast === 'function') { showToast('DOCX export coming soon! Use \"Download as HTML\" for now.', 'info'); } document.getElementById('markdownDownloadMenu').style.display = 'none'; // Placeholder implementation - would need docx.js library // Example: https://github.com/dolanmiu/docx /* const doc = new docx.Document({ sections: [{ properties: {}, children: [ new docx.Paragraph({ text: asset.content, heading: docx.HeadingLevel.TITLE, }), ], }], }); docx.Packer.toBlob(doc).then(blob => { const filename = `${sanitizeFilename(asset.name)}.docx`; downloadFile(blob, filename); }); */ } function startMarkdownAutoSave() { // Clear any existing interval if (autoSaveMarkdownInterval) { clearInterval(autoSaveMarkdownInterval); } // Auto-save every 2 seconds autoSaveMarkdownInterval = setInterval(() => { if (currentEditingMarkdownId && monacoMarkdownEditor) { saveMarkdownContent(); } }, 2000); console.log('[Markdown] Auto-save started'); } function saveMarkdownContent() { if (!currentEditingMarkdownId || !monacoMarkdownEditor) { console.warn('[Markdown] No markdown ID or editor to save'); return; } const content = monacoMarkdownEditor.getValue(); try { const stored = localStorage.getItem(`markdown_${currentPersona}`); let markdownDocs = stored ? JSON.parse(stored) : []; const index = markdownDocs.findIndex(m => m.id === currentEditingMarkdownId); if (index !== -1) { markdownDocs[index].content = content; markdownDocs[index].lastModified = new Date().toISOString(); localStorage.setItem(`markdown_${currentPersona}`, JSON.stringify(markdownDocs)); console.log('[Markdown] ✅ Auto-saved, content length:', content.length); } } catch (error) { console.error('[Markdown] ❌ Error saving:', error); } } // ======================================== // PRESENTATION EDITOR (REVEAL.JS) FUNCTIONS // ======================================== let currentEditingPresentationId = null; let currentSlideIndex = 0; let revealInstance = null; let autoSavePresentationInterval = null; // Color Harmony Generation function hexToHSL(hex) { // Convert hex to RGB const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex); if (!result) return { h: 0, s: 0, l: 50 }; let r = parseInt(result[1], 16) / 255; let g = parseInt(result[2], 16) / 255; let b = parseInt(result[3], 16) / 255; const max = Math.max(r, g, b); const min = Math.min(r, g, b); let h, s, l = (max + min) / 2; if (max === min) { h = s = 0; } else { const d = max - min; s = l > 0.5 ? d / (2 - max - min) : d / (max + min); switch (max) { case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break; case g: h = ((b - r) / d + 2) / 6; break; case b: h = ((r - g) / d + 4) / 6; break; } } return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) }; } function hslToHex(h, s, l) { s /= 100; l /= 100; const c = (1 - Math.abs(2 * l - 1)) * s; const x = c * (1 - Math.abs((h / 60) % 2 - 1)); const m = l - c / 2; let r = 0, g = 0, b = 0; if (h >= 0 && h < 60) { r = c; g = x; b = 0; } else if (h >= 60 && h < 120) { r = x; g = c; b = 0; } else if (h >= 120 && h < 180) { r = 0; g = c; b = x; } else if (h >= 180 && h < 240) { r = 0; g = x; b = c; } else if (h >= 240 && h < 300) { r = x; g = 0; b = c; } else if (h >= 300 && h < 360) { r = c; g = 0; b = x; } const toHex = (n) => { const hex = Math.round((n + m) * 255).toString(16); return hex.length === 1 ? '0' + hex : hex; }; return `#${toHex(r)}${toHex(g)}${toHex(b)}`; } function generateComplementaryColors(baseColor) { const hsl = hexToHSL(baseColor); // Generate 4 complementary colors using different harmony rules return { primary: baseColor, // Complementary (opposite on color wheel) secondary: hslToHex((hsl.h + 180) % 360, hsl.s, hsl.l), // Triadic (120 degrees apart) accent1: hslToHex((hsl.h + 120) % 360, hsl.s, hsl.l), // Triadic (240 degrees apart) accent2: hslToHex((hsl.h + 240) % 360, hsl.s, hsl.l), // Analogous (30 degrees offset, lighter) light: hslToHex((hsl.h + 30) % 360, Math.max(hsl.s - 20, 20), Math.min(hsl.l + 30, 90)) }; } // Font families for presentations const PRESENTATION_FONTS = [ { name: 'Barlow', value: 'Barlow, sans-serif' }, { name: 'Questrial', value: 'Questrial, sans-serif' }, { name: 'Arial', value: 'Arial, sans-serif' }, { name: 'Helvetica', value: 'Helvetica, sans-serif' }, { name: 'Georgia', value: 'Georgia, serif' }, { name: 'Times New Roman', value: '\"Times New Roman\", serif' }, { name: 'Courier New', value: '\"Courier New\", monospace' }, { name: 'Verdana', value: 'Verdana, sans-serif' }, { name: 'Trebuchet MS', value: '\"Trebuchet MS\", sans-serif' }, { name: 'Palatino', value: 'Palatino, serif' } ]; // Slide Templates const SLIDE_TEMPLATES = { title: { name: 'Title Slide', icon: 'ph-text-aa', content: `# Presentation Title ## Subtitle or Tagline Your Name | Date` }, content: { name: 'Content', icon: 'ph-list-bullets', content: `## Slide Title - Key point 1 - Key point 2 - Key point 3 - Animated point` }, twoColumn: { name: 'Two Column', icon: 'ph-columns', content: `## Two Column Layout"
  - generic [ref=e7]:
    - generic [ref=e8]: "### Left Column - Point 1 - Point 2"
    - generic [ref=e9]: "### Right Column - Point A - Point B"
  - text: "` }, imageText: { name: 'Image + Text', icon: 'ph-image', content: `## Title"
  - generic [ref=e10]:
    - generic [ref=e11]: "- Key point 1 - Key point 2 - Key point 3"
    - generic [ref=e12]: "![Image Description](https://via.placeholder.com/400x300)"
  - text: "` }, quote: { name: 'Quote', icon: 'ph-quotes', content: `> \"Insert your inspirational quote here\" — Author Name` }, code: { name: 'Code', icon: 'ph-code', content: `## Code Example \\`\\`\\`javascript function example() { console.log('Hello, World!'); return true; } \\`\\`\\` Explanation of the code` }, section: { name: 'Section Break', icon: 'ph-text-t', content: `# Section Title --- Next Topic` }, blank: { name: 'Blank', icon: 'ph-note-blank', content: `## New Slide Start typing...` } }; function getTemplateContent(templateKey) { return SLIDE_TEMPLATES[templateKey]?.content || SLIDE_TEMPLATES.blank.content; } function showTemplateSelector(callback) { const modal = document.createElement('div'); modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.5); z-index: 11000; display: flex; align-items: center; justify-content: center; `; const content = document.createElement('div'); content.style.cssText = ` background: white; border-radius: 12px; padding: 24px; max-width: 600px; width: 90%; `; const title = document.createElement('h3'); title.textContent = 'Choose Slide Template'; title.style.cssText = ` font-family: var(--font-family-ui); font-size: 18px; font-weight: 600; margin: 0 0 20px 0; color: var(--color-dark); `; content.appendChild(title); const grid = document.createElement('div'); grid.style.cssText = ` display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 20px; `; Object.keys(SLIDE_TEMPLATES).forEach(key => { const template = SLIDE_TEMPLATES[key]; const btn = document.createElement('button'); btn.style.cssText = ` padding: 16px 12px; background: white; border: 2px solid var(--color-neutral-border); border-radius: 8px; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 8px; transition: all 0.2s; `; btn.onmouseover = () => { btn.style.borderColor = 'var(--color-primary-blue)'; btn.style.background = '#e3f2fd'; }; btn.onmouseout = () => { btn.style.borderColor = 'var(--color-neutral-border)'; btn.style.background = 'white'; }; btn.onclick = () => { document.body.removeChild(modal); callback(key); }; const icon = document.createElement('i'); icon.className = `ph ${template.icon}`; icon.style.cssText = ` font-size: 24px; color: var(--color-primary-blue); `; const name = document.createElement('span'); name.textContent = template.name; name.style.cssText = ` font-family: var(--font-family-ui); font-size: 11px; font-weight: 600; color: var(--color-dark); text-align: center; `; btn.appendChild(icon); btn.appendChild(name); grid.appendChild(btn); }); content.appendChild(grid); const cancelBtn = document.createElement('button'); cancelBtn.textContent = 'Cancel'; cancelBtn.style.cssText = ` width: 100%; padding: 10px; background: white; border: 1px solid var(--color-neutral-border); border-radius: 6px; font-family: var(--font-family-ui); font-size: 13px; font-weight: 600; cursor: pointer; `; cancelBtn.onclick = () => document.body.removeChild(modal); content.appendChild(cancelBtn); modal.appendChild(content); document.body.appendChild(modal); } function showStyleCustomizer() { if (!currentEditingPresentationId) return; const stored = localStorage.getItem(`presentations_${currentPersona}`); const presentations = stored ? JSON.parse(stored) : []; const presentation = presentations.find(p => p.id === currentEditingPresentationId); if (!presentation) return; // Initialize custom style if not exists if (!presentation.customStyle) { presentation.customStyle = { enabled: false, baseColor: '#0066CC', backgroundColor: '#ffffff', textColor: '#333333', fontFamily: 'Barlow, sans-serif', colors: generateComplementaryColors('#0066CC') }; } const modal = document.createElement('div'); modal.style.cssText = ` position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.5); z-index: 11000; display: flex; align-items: center; justify-content: center; overflow-y: auto; `; const content = document.createElement('div'); content.style.cssText = ` background: white; border-radius: 12px; padding: 24px; max-width: 700px; width: 90%; max-height: 90vh; overflow-y: auto; `; content.innerHTML = `"
  - heading "Custom Style Settings" [level=3] [ref=e13]
  - generic [ref=e14]:
    - generic [ref=e15]:
      - checkbox "Enable Custom Style (overrides theme)" [ref=e16] [cursor=pointer]
      - generic [ref=e17] [cursor=pointer]: Enable Custom Style (overrides theme)
    - generic [ref=e18]:
      - generic [ref=e19]: Font Family
      - combobox [ref=e20] [cursor=pointer]:
        - text: "${PRESENTATION_FONTS.map(font => `"
        - 'option "${font.name}" [selected]'
        - text: "` ).join('')}"
    - generic [ref=e21]:
      - generic [ref=e22]: Base Color (generates complementary colors)
      - generic [ref=e23]:
        - textbox [ref=e24] [cursor=pointer]: "#000000"
        - textbox [ref=e25]: "${presentation.customStyle.baseColor}"
        - button "Generate" [ref=e26] [cursor=pointer]
    - generic [ref=e27]:
      - generic [ref=e28]: Background Color
      - generic [ref=e29]:
        - textbox [ref=e30] [cursor=pointer]: "#000000"
        - textbox [ref=e31]: "${presentation.customStyle.backgroundColor}"
    - generic [ref=e32]:
      - generic [ref=e33]: Text Color
      - generic [ref=e34]:
        - textbox [ref=e35] [cursor=pointer]: "#000000"
        - textbox [ref=e36]: "${presentation.customStyle.textColor}"
    - generic [ref=e37]:
      - button "Apply Style" [ref=e38] [cursor=pointer]
      - button "Cancel" [ref=e39] [cursor=pointer]
  - text: "`; // Add event listeners for color sync content.querySelector('#customBaseColor').addEventListener('input', (e) => { content.querySelector('#customBaseColorHex').value = e.target.value; }); content.querySelector('#customBaseColorHex').addEventListener('input', (e) => { if (/^#[0-9A-F]{6}$/i.test(e.target.value)) { content.querySelector('#customBaseColor').value = e.target.value; } }); content.querySelector('#customBackgroundColor').addEventListener('input', (e) => { content.querySelector('#customBackgroundColorHex').value = e.target.value; }); content.querySelector('#customBackgroundColorHex').addEventListener('input', (e) => { if (/^#[0-9A-F]{6}$/i.test(e.target.value)) { content.querySelector('#customBackgroundColor').value = e.target.value; } }); content.querySelector('#customTextColor').addEventListener('input', (e) => { content.querySelector('#customTextColorHex').value = e.target.value; }); content.querySelector('#customTextColorHex').addEventListener('input', (e) => { if (/^#[0-9A-F]{6}$/i.test(e.target.value)) { content.querySelector('#customTextColor').value = e.target.value; } }); // Define global functions BEFORE appending modal window.updateColorPalettePreview = function(colors) { const preview = document.getElementById('colorPalettePreview'); if (!preview) return; const colorRoles = [ { key: 'primary', label: 'Primary', desc: 'Main brand color' }, { key: 'secondary', label: 'Secondary', desc: 'Complementary accent' }, { key: 'accent1', label: 'Accent 1', desc: 'Triadic harmony' }, { key: 'accent2', label: 'Accent 2', desc: 'Triadic harmony' }, { key: 'light', label: 'Light', desc: 'Backgrounds/subtle' } ]; preview.innerHTML = `"
  - generic [ref=e40]:
    - text: "${colorRoles.map(role => `"
    - generic [ref=e41]:
      - generic [ref=e43]: "${role.label}"
      - generic [ref=e44]: "${colors[role.key]}"
      - generic [ref=e45]: "${role.desc}"
    - text: "`).join('')}"
  - text: "`; }; window.regenerateColors = function() { const baseColor = document.getElementById('customBaseColor').value; const colors = generateComplementaryColors(baseColor); window.updateColorPalettePreview(colors); }; window.saveCustomStyle = function() { const stored = localStorage.getItem(`presentations_${currentPersona}`); let presentations = stored ? JSON.parse(stored) : []; const index = presentations.findIndex(p => p.id === currentEditingPresentationId); if (index !== -1) { const baseColor = document.getElementById('customBaseColor').value; presentations[index].customStyle = { enabled: document.getElementById('customStyleEnabled').checked, baseColor: baseColor, backgroundColor: document.getElementById('customBackgroundColor').value, textColor: document.getElementById('customTextColor').value, fontFamily: document.getElementById('customFontFamily').value, colors: generateComplementaryColors(baseColor) }; presentations[index].lastModified = new Date().toISOString(); localStorage.setItem(`presentations_${currentPersona}`, JSON.stringify(presentations)); console.log('[Presentation] Custom style saved'); document.body.removeChild(modal); updateRevealPreview(); } }; window.closeStyleCustomizer = function() { document.body.removeChild(modal); }; modal.appendChild(content); document.body.appendChild(modal); modal.id = 'styleCustomizerModal'; // Show color palette after modal is in DOM window.updateColorPalettePreview(presentation.customStyle.colors); } function openPresentationByIdReveal(id) { console.log('=== OPENING PRESENTATION ==='); console.log('[Presentation] ID:', id); const stored = localStorage.getItem(`presentations_${currentPersona}`); const presentations = stored ? JSON.parse(stored) : []; const presentation = presentations.find(p => p.id === id); if (!presentation) { console.error('[Presentation] Not found with ID:', id); alert('Presentation not found'); return; } console.log('[Presentation] Found:', { id: presentation.id, name: presentation.name, slideCount: presentation.slides ? presentation.slides.length : 0 }); currentEditingPresentationId = id; currentSlideIndex = 0; // Show editor document.getElementById('presentationEditor').style.display = 'flex'; document.getElementById('presentationEditorTitle').textContent = presentation.name || 'Untitled Presentation'; // Set theme and transition document.getElementById('presentationThemeSelect').value = presentation.theme || 'white'; document.getElementById('presentationTransitionSelect').value = presentation.transition || 'slide'; // Load first slide if (presentation.slides && presentation.slides.length > 0) { loadSlide(0); } // Render slides list renderSlidesList(); // Initialize Reveal.js initializeReveal(); // Start auto-save startPresentationAutoSave(); console.log('[Presentation] ✅ Editor opened'); } function closePresentationEditor() { console.log('=== CLOSING PRESENTATION EDITOR ==='); // Stop auto-save if (autoSavePresentationInterval) { clearInterval(autoSavePresentationInterval); autoSavePresentationInterval = null; } // Save one last time before closing if (currentEditingPresentationId) { savePresentationSilently(); } // Destroy Reveal instance if (revealInstance) { try { revealInstance.destroy(); revealInstance = null; } catch (e) { console.warn('[Presentation] Error destroying Reveal:', e); } } // Hide editor document.getElementById('presentationEditor').style.display = 'none'; currentEditingPresentationId = null; currentSlideIndex = 0; // Reload assets list if (typeof loadAllAssets === 'function') { loadAllAssets(); } console.log('[Presentation] ✅ Editor closed'); } function savePresentationSilently() { if (!currentEditingPresentationId) { console.warn('[Presentation] No presentation ID to save'); return; } try { const stored = localStorage.getItem(`presentations_${currentPersona}`); let presentations = stored ? JSON.parse(stored) : []; const index = presentations.findIndex(p => p.id === currentEditingPresentationId); if (index !== -1) { // Save current slide content const slideContent = document.getElementById('slideContentTextarea').value; presentations[index].slides[currentSlideIndex].content = slideContent; presentations[index].lastModified = new Date().toISOString(); localStorage.setItem(`presentations_${currentPersona}`, JSON.stringify(presentations)); console.log('[Presentation] ✅ Auto-saved, slide:', currentSlideIndex); } } catch (error) { console.error('[Presentation] ❌ Error saving:', error); } } function startPresentationAutoSave() { // Clear any existing interval if (autoSavePresentationInterval) { clearInterval(autoSavePresentationInterval); } // Auto-save every 2 seconds autoSavePresentationInterval = setInterval(() => { if (currentEditingPresentationId) { savePresentationSilently(); } }, 2000); console.log('[Presentation] Auto-save started'); } function addSlideToPresentation() { if (!currentEditingPresentationId) return; // Show template selector showTemplateSelector((templateKey) => { const stored = localStorage.getItem(`presentations_${currentPersona}`); let presentations = stored ? JSON.parse(stored) : []; const index = presentations.findIndex(p => p.id === currentEditingPresentationId); if (index !== -1) { // Save current slide first savePresentationSilently(); // Add new slide with selected template const newSlide = { id: Date.now().toString(), type: templateKey, content: getTemplateContent(templateKey) }; presentations[index].slides.push(newSlide); presentations[index].lastModified = new Date().toISOString(); localStorage.setItem(`presentations_${currentPersona}`, JSON.stringify(presentations)); // Switch to new slide currentSlideIndex = presentations[index].slides.length - 1; loadSlide(currentSlideIndex); renderSlidesList(); updateRevealPreview(); console.log('[Presentation] ✅ Added new slide with template:', templateKey); } }); } function deleteSlideFromPresentation(slideIndex) { if (!currentEditingPresentationId) return; const stored = localStorage.getItem(`presentations_${currentPersona}`); let presentations = stored ? JSON.parse(stored) : []; const index = presentations.findIndex(p => p.id === currentEditingPresentationId); if (index !== -1 && presentations[index].slides.length > 1) { if (!confirm('Delete this slide?')) return; presentations[index].slides.splice(slideIndex, 1); presentations[index].lastModified = new Date().toISOString(); localStorage.setItem(`presentations_${currentPersona}`, JSON.stringify(presentations)); // Adjust current slide index if (currentSlideIndex >= presentations[index].slides.length) { currentSlideIndex = presentations[index].slides.length - 1; } loadSlide(currentSlideIndex); renderSlidesList(); updateRevealPreview(); console.log('[Presentation] ✅ Deleted slide', slideIndex); } else { alert('Cannot delete the last slide'); } } function selectSlide(slideIndex) { // Save current slide first savePresentationSilently(); // Switch to selected slide currentSlideIndex = slideIndex; loadSlide(slideIndex); } function loadSlide(slideIndex) { if (!currentEditingPresentationId) return; const stored = localStorage.getItem(`presentations_${currentPersona}`); const presentations = stored ? JSON.parse(stored) : []; const presentation = presentations.find(p => p.id === currentEditingPresentationId); if (presentation && presentation.slides[slideIndex]) { const slide = presentation.slides[slideIndex]; document.getElementById('slideContentTextarea').value = slide.content || ''; document.getElementById('currentSlideNumber').textContent = `Slide ${slideIndex + 1} of ${presentation.slides.length}`; // Update active state in slides list renderSlidesList(); updateRevealPreview(); } } function renderSlidesList() { if (!currentEditingPresentationId) return; const stored = localStorage.getItem(`presentations_${currentPersona}`); const presentations = stored ? JSON.parse(stored) : []; const presentation = presentations.find(p => p.id === currentEditingPresentationId); if (!presentation) return; const slidesList = document.getElementById('slidesList'); slidesList.innerHTML = ''; presentation.slides.forEach((slide, index) => { const slideItem = document.createElement('div'); slideItem.style.cssText = ` padding: 12px; background: ${index === currentSlideIndex ? 'var(--color-primary-blue)' : 'white'}; color: ${index === currentSlideIndex ? 'white' : 'var(--color-dark)'}; border: 1px solid ${index === currentSlideIndex ? 'var(--color-primary-blue)' : 'var(--color-neutral-border)'}; border-radius: 6px; cursor: pointer; font-family: var(--font-family-ui); font-size: 12px; font-weight: 600; display: flex; align-items: center; justify-content: space-between; transition: all 0.2s; `; slideItem.onclick = () => selectSlide(index); const slideNumber = document.createElement('span'); slideNumber.textContent = `Slide ${index + 1}`; slideItem.appendChild(slideNumber); if (presentation.slides.length > 1) { const deleteBtn = document.createElement('button'); deleteBtn.innerHTML = '"
  - generic [ref=e46]: 
  - text: "'; deleteBtn.style.cssText = ` background: none; border: none; color: ${index === currentSlideIndex ? 'white' : 'var(--color-neutral-text)'}; font-size: 16px; cursor: pointer; padding: 4px; display: flex; align-items: center; justify-content: center; `; deleteBtn.onclick = (e) => { e.stopPropagation(); deleteSlideFromPresentation(index); }; slideItem.appendChild(deleteBtn); } slidesList.appendChild(slideItem); }); } function updateRevealPreview() { if (!currentEditingPresentationId) return; const stored = localStorage.getItem(`presentations_${currentPersona}`); const presentations = stored ? JSON.parse(stored) : []; const presentation = presentations.find(p => p.id === currentEditingPresentationId); if (!presentation) { console.warn('[Presentation] Presentation not found for preview update'); return; } // Get current slide content const slideContent = document.getElementById('slideContentTextarea').value; // Update slides array with current content if (presentation.slides[currentSlideIndex]) { presentation.slides[currentSlideIndex].content = slideContent; } console.log('[Presentation] Updating preview, total slides:', presentation.slides.length); console.log('[Presentation] Current slide index:', currentSlideIndex); // Regenerate preview HTML - create sections dynamically for better rendering const previewSlides = document.getElementById('previewSlides'); previewSlides.innerHTML = ''; // Clear first presentation.slides.forEach((slide, index) => { const section = document.createElement('section'); section.setAttribute('data-markdown', ''); const textarea = document.createElement('textarea'); textarea.setAttribute('data-template', ''); textarea.textContent = slide.content; section.appendChild(textarea); previewSlides.appendChild(section); }); console.log('[Presentation] Preview HTML updated with', presentation.slides.length, 'slides'); // Always reinitialize Reveal for markdown to be properly rendered setTimeout(() => { initializeReveal(); }, 100); } function initializeReveal() { const previewContainer = document.getElementById('revealPreview'); if (typeof Reveal === 'undefined') { console.error('[Presentation] Reveal.js not loaded'); return; } console.log('[Presentation] Initializing Reveal.js...'); try { if (revealInstance) { try { revealInstance.destroy(); console.log('[Presentation] Previous instance destroyed'); } catch (e) { console.warn('[Presentation] Error destroying previous instance:', e); } revealInstance = null; } const revealElement = previewContainer.querySelector('.reveal'); if (!revealElement) { console.error('[Presentation] .reveal element not found'); return; } revealInstance = new Reveal(revealElement, { embedded: true, width: 960, height: 700, margin: 0.1, minScale: 0.2, maxScale: 2.0, controls: true, progress: true, center: true, hash: false, slideNumber: true, transition: document.getElementById('presentationTransitionSelect').value || 'slide', plugins: [ RevealMarkdown ] }); revealInstance.initialize().then(() => { console.log('[Presentation] ✅ Reveal initialized, navigating to slide:', currentSlideIndex); revealInstance.slide(currentSlideIndex, 0, 0); // Apply custom styles if enabled applyCustomStyles(); }).catch(error => { console.error('[Presentation] ❌ Error during initialization:', error); }); } catch (error) { console.error('[Presentation] ❌ Error initializing Reveal:', error); } } function applyCustomStyles() { if (!currentEditingPresentationId) return; const stored = localStorage.getItem(`presentations_${currentPersona}`); const presentations = stored ? JSON.parse(stored) : []; const presentation = presentations.find(p => p.id === currentEditingPresentationId); if (!presentation || !presentation.customStyle || !presentation.customStyle.enabled) { // Remove custom style if exists const existingStyle = document.getElementById('customPresentationStyle'); if (existingStyle) existingStyle.remove(); return; } const style = presentation.customStyle; const colors = style.colors; // Remove existing custom style const existingStyle = document.getElementById('customPresentationStyle'); if (existingStyle) existingStyle.remove(); // Create new style element const styleElement = document.createElement('style'); styleElement.id = 'customPresentationStyle'; styleElement.textContent = ` /* Custom Presentation Styles */ #revealPreview .reveal { font-family: ${style.fontFamily} !important; } #revealPreview .reveal .slides { background: ${style.backgroundColor} !important; } #revealPreview .reveal h1, #revealPreview .reveal h2, #revealPreview .reveal h3, #revealPreview .reveal h4, #revealPreview .reveal h5, #revealPreview .reveal h6 { color: ${colors.primary} !important; font-family: ${style.fontFamily} !important; } #revealPreview .reveal p, #revealPreview .reveal li, #revealPreview .reveal td, #revealPreview .reveal th { color: ${style.textColor} !important; font-family: ${style.fontFamily} !important; } #revealPreview .reveal a { color: ${colors.secondary} !important; } #revealPreview .reveal a:hover { color: ${colors.accent1} !important; } #revealPreview .reveal code { background: ${colors.light} !important; color: ${style.textColor} !important; } #revealPreview .reveal blockquote { border-left: 5px solid ${colors.accent1} !important; background: ${colors.light} !important; } #revealPreview .reveal .controls { color: ${colors.primary} !important; } #revealPreview .reveal .progress { background: ${colors.light} !important; } #revealPreview .reveal .progress span { background: ${colors.primary} !important; } #revealPreview .reveal section { background: ${style.backgroundColor} !important; } #revealPreview .reveal strong, #revealPreview .reveal b { color: ${colors.accent2} !important; } #revealPreview .reveal em, #revealPreview .reveal i { color: ${colors.secondary} !important; } `; document.head.appendChild(styleElement); console.log('[Presentation] ✅ Custom styles applied'); } function changePresentationTheme() { const theme = document.getElementById('presentationThemeSelect').value; // Update theme stylesheet const themeLink = document.getElementById('revealTheme'); if (themeLink) { themeLink.href = `https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/dist/theme/${theme}.css`; } // Save theme to presentation if (currentEditingPresentationId) { const stored = localStorage.getItem(`presentations_${currentPersona}`); let presentations = stored ? JSON.parse(stored) : []; const index = presentations.findIndex(p => p.id === currentEditingPresentationId); if (index !== -1) { presentations[index].theme = theme; presentations[index].lastModified = new Date().toISOString(); localStorage.setItem(`presentations_${currentPersona}`, JSON.stringify(presentations)); console.log('[Presentation] Theme changed to:', theme); } } } function changePresentationTransition() { const transition = document.getElementById('presentationTransitionSelect').value; // Save transition to presentation if (currentEditingPresentationId) { const stored = localStorage.getItem(`presentations_${currentPersona}`); let presentations = stored ? JSON.parse(stored) : []; const index = presentations.findIndex(p => p.id === currentEditingPresentationId); if (index !== -1) { presentations[index].transition = transition; presentations[index].lastModified = new Date().toISOString(); localStorage.setItem(`presentations_${currentPersona}`, JSON.stringify(presentations)); console.log('[Presentation] Transition changed to:', transition); // Update Reveal instance if (revealInstance) { revealInstance.configure({ transition: transition }); } } } } function startPresentationMode() { if (!currentEditingPresentationId) return; // Save current state savePresentationSilently(); const stored = localStorage.getItem(`presentations_${currentPersona}`); const presentations = stored ? JSON.parse(stored) : []; const presentation = presentations.find(p => p.id === currentEditingPresentationId); if (!presentation) return; // Create full-screen presentation window const presentWindow = window.open('', '_blank', 'width=1920,height=1080,fullscreen=yes'); if (!presentWindow) { alert('Please allow popups to start presentation mode'); return; } // Build presentation HTML const slidesHTML = presentation.slides.map(slide => { return `"
  - textbox [ref=e48]: "${slide.content}"
  - text: "`; }).join('\\n'); // Generate custom style CSS if enabled let customStyleCSS = ''; if (presentation.customStyle && presentation.customStyle.enabled) { const style = presentation.customStyle; const colors = style.colors; customStyleCSS = ` /* Custom Presentation Styles */ .reveal { font-family: ${style.fontFamily} !important; } .reveal .slides { background: ${style.backgroundColor} !important; } .reveal h1, .reveal h2, .reveal h3 { color: ${colors.primary} !important; } .reveal p, .reveal li { color: ${style.textColor} !important; } .reveal a { color: ${colors.secondary} !important; } .reveal a:hover { color: ${colors.accent1} !important; } .reveal code { background: ${colors.light} !important; color: ${style.textColor} !important; } .reveal pre { background: ${colors.light} !important; } .reveal blockquote { border-left: 5px solid ${colors.accent1} !important; background: ${colors.light} !important; } .reveal strong { color: ${colors.accent2} !important; } .reveal .controls { color: ${colors.primary} !important; } .reveal .progress { background: ${colors.light} !important; } .reveal .progress span { background: ${colors.primary} !important; }`; } const htmlContent = `"
  - generic:
    - generic: "${slidesHTML}"
```